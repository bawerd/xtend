{
  "name": "modul8",
  "description": "Extensible CommonJS Code Packager and Analyzer",
  "version": "0.16.0",
  "author": {
    "name": "Eirik Albrigtsen",
    "email": "analsandblaster@gmail.com"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/clux/modul8.git"
  },
  "main": "index.js",
  "bin": {
    "modul8": "./bin/cli.js"
  },
  "scripts": {
    "test": "expresso"
  },
  "dependencies": {
    "commander": "~0.3.3",
    "uglify-js": "~1.1.1",
    "deputy": "~0.0.0",
    "underscore": "~1.3.1",
    "logule": "~0.6.1",
    "topiary": "~0.0.1"
  },
  "devDependencies": {
    "zombie": "~0.12.1",
    "expresso": "~0.9.2",
    "rimraf": "~1.0.8",
    "mkdirp": "~0.2.1"
  },
  "keywords": [
    "browser",
    "require",
    "commonjs",
    "bundle",
    "compiler",
    "analyzer",
    "javascript",
    "cli"
  ],
  "engines": {
    "node": ">=0.4.10"
  },
  "bugs": {
    "url": "http://github.com/clux/modul8/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/clux/modul8/raw/master/LICENSE"
    }
  ],
  "optionalDependencies": {},
  "readme": "# Extensible CommonJS Code Packager and Analyzer ![travis build status](https://secure.travis-ci.org/clux/modul8.png)\n## Intro\n\nWrite a `main.js` as the application entry point\n\n````javascript\nvar determine = require('./determine');\nconsole.log(determine.isCool(['clux', 'lava']));\n````\n\nthe required module `determine.js`\n\n````javascript\nvar cool = require('shared::cool'); // cross-domain require\nexports.isCool = function (input) {\n  return input.filter(cool);\n};\n````\n\nand finally its required `cool.js` on the `shared` domain [?](http://clux.github.com/modul8/docs/xcjs.html#modul8extensions)\n\n````javascript\nmodule.exports = function (name) {\n  return (name === 'clux');\n};\n````\n\nTo compile these files invoke `modul8()` and chain on options\n\n````javascript\nvar modul8 = require('modul8');\n\nmodul8('./client/main.js')\n  .domains({'shared': './shared/'})\n  .compile('./out.js');\n````\n\nThis will construct a single, browser compatible `out.js` in your execution path, and the generated dependency tree will look as follows:\n\n    app::main\n    └──┬app::determine\n       └───shared::cool\n\nThe shared code is independent of the application and **can be reused on the server**.\n\nCompilation can also be performed via the command line interface by typing\n\n````bash\n$ modul8 client/main.js -p shared:shared/ > out.js\n````\n\nfrom the path containing the shared/ and client/ folders.\n\nTo load the browser compatible output file from your site simply stick it in the HTML\n\n````html\n<script src=\"/out.js\"></script>\n````\n\n## Quick Overview\n\nmodul8 is an extensible CommonJS code packager and analyzer for JavaScript and AltJS web applications.\nApplications are recursively analyzed for dependencies from an entry point and will pull in + compile just what is needed.\n\nCode can be shared with the server by isolating modules/libraries in  shared _domains_. This means stand alone logic\ncan exist on the server and be referenced via a normal `require(dir + 'module')`, but also be referenced via `require('shared::module')` on the client.\n\nTo give you full overview and control over what code is pulled in, modul8 automatically generates a per-file depedency tree. This allows\nfast analysis and identification of extraneous links, and becomes a very useful tool for refactoring.\n\nmodul8 supports live extensions of certain exports containers via third party script loaders, and server side data injection at compile time.\n\nLastly, modul8 aims to eliminate most global variables from your code. It does so using the following approaches\n\n - Encapsulate all exported data in the closure inhabited by `require()`\n - Incorporate globally available libraries into the module system via automatic arbiters\n\nAdditionally, node modules can be required (if installed) as if on the server!\nTo dive in properly; consult the [api docs](http://clux.github.com/modul8/docs/api.html).\n\n## Features\n\n - highly extensible client side require\n - simple and safe code sharing between the server and the client\n - dynamic resolution and compilation of dependencies server-side\n - compatible with JavaScript, CoffeeScript or (configurable) AltJS languages\n - low footprint: <2kB (minified/gzipped) output size inflation\n - enforces modularity best practices and logs an npm style dependency tree\n - can inject data to require dynamically from the server or live from the client\n - can require npm installed modules\n - easy to write, modular plugins allows super easy client extensions with server logic and data\n - minimizes global usage, encapsulates exports in closures, absorbs library globals\n - only rebuilds on repeat calls if necessary (files modified || options changed)\n - ideal for single page web applications, 1 or 2 HTTP request to get all code\n\n## Installation\n\nInstall the library:\n\n````bash\n$ npm install modul8\n````\n\nInstall the command line tool:\n\n````bash\n$ npm install -g modul8\n````\n\nDownload the development version:\n\n````bash\n$ git clone git://github.com/clux/modul8\n````\n\n## Usage\nBasic use only only the path to the entry point and an output.\n\n````javascript\nmodul8('./client/app.js').compile('./out.js');\n````\n\nThis compiles everything referenced explicitly through `app.js` to the single browser compatible `out.js`.\n\n\nEvery `require()` call is tracked and the resulting dependency tree is loggable. Cross domain `require()`s are namespaced\nC++ style: `require('shared::validation')` will look for a `.js` then `.coffee` file named `validation` on the shared domain.\nThis extra domain must be configured using a chained `.domains()` call:\n\n````javascript\nmodul8('./client/app.js')\n  .domains({'shared': './shared/'})\n  .compile('./out.js');\n````\n\nTo ensure that the `shared` domain here can work on the server and the client, any `require()` calls within domains\nshould be relative and not pull in anything outside that folder.\nAs an example, a same-origin require of `shared::defs` should be done with a **./** prefix:  `require('./defs')`.\n\nThe dependency analyzer will typically output something like this if configured\n\n    app::app\n    ├──┬app::controllers/user\n    │  └───app::models/user\n    ├──┬app::controllers/entries\n    │  └───app::models/entry\n    ├──┬shared::validation\n    │  └───shared::defs\n    └───M8::jQuery\n\n`jQuery` can be seemlessly integrated (and will show up in the dependency tree as above) by using `.arbiters()`\n\n## Injecting Data\n\nData can by injected at compile time from the server by specifying keys and serializable/pre-serialized data to be attatched on the specified key\n\n````javascript\nmodul8('./client/app.js')\n  .data({'models': {'user':'clux'}})\n  .compile('./out.js');\n````\n\nThe `data` domain is initialized from the server with every key specified to `.data()`, but can be extended live on the client.\nThe data API is particularly useful for web applications that needs particular application data to always be bundled.\nAnything that can be serialized (including pre-serialized javascript input) can be sent to the data domain.\n\n## Using Plugins\nExtending the data domain in conjunction with creating specialized domains to handle that data,\nis a popular method that can be employed by node modules to break browser code down into more managable chunks - while linking them to the server.\n\nThis is so useful that it has become the defacto plugin API.\n\n````javascript\nmodul8('./client/app.js')\n  .use(new Plugin(opts))\n  .compile('./out.js');\n````\n\nThis will allow the Plugin to extend 'out.js' with data created in Plugin, as well as add a namespaced require domain on the browser.\nUsing a Plugin will inflate 'out.js' by the size of the data it creates plus **only the size of the modules you explicitly `require()`**.\n\nThus, adding plugins is a remarkably safe, monitorable, and robust way, to get discrete units of code - that shares logic with the server - to the client.\n\nWriting your own plugins is also really easy. Please share.\n\n### Available Plugins\n\n- [m8-mongoose](https://www.github.com/clux/m8-mongoose)\n- [m8-templation](https://www.github.com/clux/m8-templation)\n\n## External Injection\n\nFinally, modul8 defines an `external` domain for asynchronous script loaders to dump their results. This domain can only be used and extended from the client.\n\nBoth the `data` and `external` domains are only allowed to be modified through safe proxies. Objects residing on these domains can be referenced\nwith `require()` without messing up the compile time code analysis, but they can still show up in the dependency tree if desirable.\n\n## Learn more\n\nThe [full documentation site](http://clux.github.com/modul8) should contain everything you could ever want to know about modul8 and probably more.\nRead it, try it out, and give feedback if you like or hate it / parts of it, or if you want to contribute.\n\nmodul8 is my first proper open source project. It was crafted out of necessity, but it has grown into something larger.\nVersion 1.0 should be ready relatively soon - so the current code can be considered mostly stable.\n\nVersion 0.10.0 and up should work fine with node v0.6.\n\n## Compatibility\nCompiled code will work with ES5 compatible browsers (recent browsers minus Opera)\nIf you target older browsers, include [ES5-shim](https://github.com/kriskowal/es5-shim).\n\n## Running Tests\n\nInstall development dependencies\n\n````bash\n$ npm install\n````\n\nRun the tests\n\n````bash\n$ npm test\n````\n\nmodul8 is actively tested with the latest node 0.6 branch.\nMany thanks to Travis-CI.\n\n## License\n\nMIT Licensed - See LICENSE file for details\n",
  "readmeFilename": "Readme.md",
  "_id": "modul8@0.16.0",
  "dist": {
    "shasum": "25853bdf6ff7d39f847b4c7b2d8746b55c0da691"
  },
  "_from": "modul8@0.16.0",
  "_resolved": "https://registry.npmjs.org/modul8/-/modul8-0.16.0.tgz"
}
