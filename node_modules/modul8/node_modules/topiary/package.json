{
  "author": {
    "name": "Eirik Albrigtsen",
    "email": "analsandblaster@gmail.com"
  },
  "name": "topiary",
  "description": "Prettify and shape tree structures for printing",
  "version": "0.0.1",
  "repository": {
    "type": "git",
    "url": "git://github.com/clux/topiary.git"
  },
  "scripts": {
    "test": "node test/basic.js"
  },
  "main": "topiary.js",
  "engines": {
    "node": ">= 0.4.6"
  },
  "dependencies": {},
  "devDependencies": {},
  "optionalDependencies": {},
  "readme": "# Topiary ![travis build status](https://secure.travis-ci.org/clux/topiary.png)\n\nTopiary is a utility that shapes tree structures into nice prettified formats ala `npm list`.\n\n## Usage\nBasic usage:\n\n````javascript\nvar topiary = require('topiary');\nconsole.log(topiary(tree, recurseName, shapeFn));\n````\n\nBasic output:\n\n````\nroot\n ├───sub1Name\n ├──┬sub2Name\n │  └───sub2subName\n └───sub3Name\n````\n\n## Example\n`tree` is the recursively structured tree structured recursively with `recurseName`,\ni.e. with `recurseName = 'deps'` the tree printed above can look like this:\n\n````javascript\nvar tree = {\n  name: \"root\"\n, deps: {\n    sub1 : {\n      name : 'sub1Name'\n    , deps : {}\n    }\n  , sub2 : {\n      name : 'sub2Name'\n    , deps : {\n        sub2sub : {\n          name : 'sub2subName'\n        , deps : {}\n        }\n      }\n    }\n  , sub3 : {\n      name : 'sub3Name'\n    , deps : {}\n    }\n  }\n};\n````\n\n`shapeFn` is passed the element (for instance `tree.deps['sub1']`) and must return the\nstring that should be used to name this element.\n\nIf your structure is simple (like above) and only has a name property, you can return that:\n\n````javascript\nvar shapeFn = function (el) { return el.name };\n````\n\nOtherwise, you can shape the corresponding string anyway you like from the passed in branch.\n\nUsing this `shapeFn` and `tree` we can produce the above output as follows:\n\n````javascript\nconsole.log(topiary(tree, 'deps', shapeFn));\n````\n\n### filterFn\nYou can optionally pass in a function to help filter certain branches or leafs.\nAny children of an ignored element are ignored.\n\n````javascript\nvar filterFn = function (el) {\n  if (el.name === 'sub2Name') {\n    return false;\n  }\n  return true;\n};\nconsole.log(topiary(tree, 'deps', shapeFn, filterFn));\n````\n\n````\nroot\n ├───sub1Name\n └───sub3Name\n````\n\n\n## Installation\n\n````bash\n$ npm install topiary\n````\n\n## Running tests\n\n````bash\n$ npm test\n````\n\n## License\nMIT-Licensed. See LICENSE file for details.\n",
  "readmeFilename": "Readme.md",
  "_id": "topiary@0.0.1",
  "dist": {
    "shasum": "e9a9090d24c4057c962973096e11815aac936fc5"
  },
  "_from": "topiary@~0.0.1",
  "_resolved": "https://registry.npmjs.org/topiary/-/topiary-0.0.1.tgz"
}
